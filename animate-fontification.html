<html>
  <head>
    <link rel="stylesheet" href="css/highlight.css">
    <script src="js/highlight.min.js"></script>
    <script src="js/jquery.min.js"></script>
  </head>
  <body>
    <div class="window" style="position: absolute; border: solid; padding-left: 2%; padding-right: 2%; width: 60%; height: 200px;"></div>
    <pre>
      <code class="c++ hljs code">
static int
fill_column_indicator_column (struct it *it, int char_width)
{
  if (Vdisplay_fill_column_indicator
      && !it->w->pseudo_window_p
      && it->continuation_lines_width == 0
      && CHARACTERP (Vdisplay_fill_column_indicator_character))
    {
      Lisp_Object col = (EQ (Vdisplay_fill_column_indicator_column, Qt)
			 ? BVAR (current_buffer, fill_column)
			 : Vdisplay_fill_column_indicator_column);

      /* The stretch width needs to consider the latter
	 added glyph in append_space_for_newline.  */
      if (RANGED_FIXNUMP (0, col, INT_MAX))
	{
          int icol = XFIXNUM (col);
	  if (!INT_MULTIPLY_WRAPV (char_width, icol, &icol)
	      && !INT_ADD_WRAPV (it->lnum_pixel_width, icol, &icol))
	    return icol;
	}
    }
  return -1;
}

/* True means print newline to stdout before next mini-buffer message.  */

bool noninteractive_need_newline;

/* True means print newline to message log before next message.  */

static bool message_log_need_newline;

/* Three markers that message_dolog uses.
   It could allocate them itself, but that causes trouble
   in handling memory-full errors.  */
static Lisp_Object message_dolog_marker1;
static Lisp_Object message_dolog_marker2;
static Lisp_Object message_dolog_marker3;

/* The buffer position of the first character appearing entirely or
   partially on the line of the selected window which contains the
   cursor; <= 0 if not known.  Set by set_cursor_from_row, used for
   redisplay optimization in redisplay_internal.  */

static struct text_pos this_line_start_pos;

/* Number of characters past the end of the line above, including the
   terminating newline.  */

static struct text_pos this_line_end_pos;

/* The vertical positions and the height of this line.  */

static int this_line_vpos;
static int this_line_y;
static int this_line_pixel_height;

/* X position at which this display line starts.  Usually zero;
   negative if first character is partially visible.  */

static int this_line_start_x;

/* The smallest character position seen by move_it_* functions as they
   move across display lines.  Used to set MATRIX_ROW_START_CHARPOS of
   hscrolled lines, see display_line.  */

static struct text_pos this_line_min_pos;

/* Buffer that this_line_.* variables are referring to.  */

static struct buffer *this_line_buffer;

/* True if an overlay arrow has been displayed in this window.  */

static bool overlay_arrow_seen;

/* Vector containing glyphs for an ellipsis `...'.  */

static Lisp_Object default_invis_vector[3];

/* This is the window where the echo area message was displayed.  It
   is always a mini-buffer window, but it may not be the same window
   currently active as a mini-buffer.  */

Lisp_Object echo_area_window;

/* Stack of messages, which are pushed by push_message and popped and
   displayed by restore_message.  */

static Lisp_Object Vmessage_stack;

/* True means multibyte characters were enabled when the echo area
   message was specified.  */

static bool message_enable_multibyte;

/* At each redisplay cycle, we should refresh everything there is to refresh.
   To do that efficiently, we use many optimizations that try to make sure we
   don't waste too much time updating things that haven't changed.
   The coarsest such optimization is that, in the most common cases, we only
   look at the selected-window.

   To know whether other windows should be considered for redisplay, we use the
   variable windows_or_buffers_changed: as long as it is 0, it means that we
   have not noticed anything that should require updating anything else than
   the selected-window.  If it is set to REDISPLAY_SOME, it means that since
   last redisplay, some changes have been made which could impact other
   windows.  To know which ones need redisplay, every buffer, window, and frame
   has a `redisplay' bit, which (if true) means that this object needs to be
   redisplayed.  If windows_or_buffers_changed is 0, we know there's no point
   looking for those `redisplay' bits (actually, there might be some such bits
   set, but then only on objects which aren't displayed anyway).

   OTOH if it's non-zero we will have to loop through all windows and then
   check the `redisplay' bit of the corresponding window, frame, and buffer, in
   order to decide whether that window needs attention or not.  Note that we
   can't just look at the frame's redisplay bit to decide that the whole frame
   can be skipped, since even if the frame's redisplay bit is unset, some of
   its windows's redisplay bits may be set.

   Mostly for historical reasons, windows_or_buffers_changed can also take
   other non-zero values.  In that case, the precise value doesn't matter (it
   encodes the cause of the setting but is only used for debugging purposes),
   and what it means is that we shouldn't pay attention to any `redisplay' bits
   and we should simply try and redisplay every window out there.  */

int windows_or_buffers_changed;

/* Nonzero if we should redraw the mode lines on the next redisplay.
   Similarly to `windows_or_buffers_changed', if it has value REDISPLAY_SOME,
   then only redisplay the mode lines in those buffers/windows/frames where the
   `redisplay' bit has been set.
   For any other value, redisplay all mode lines (the number used is then only
   used to track down the cause for this full-redisplay).

   Since the frame title uses the same %-constructs as the mode line
   (except %c, %C, and %l), if this variable is non-zero, we also consider
   redisplaying the title of each frame, see gui_consider_frame_title.

   The `redisplay' bits are the same as those used for
   windows_or_buffers_changed, and setting windows_or_buffers_changed also
   causes recomputation of the mode lines of all those windows.  IOW this
   variable only has an effect if windows_or_buffers_changed is zero, in which
   case we should only need to redisplay the mode-line of those objects with
   a `redisplay' bit set but not the window's text content (tho we may still
   need to refresh the text content of the selected-window).  */

int update_mode_lines;

/* True after display_mode_line if %l was used and it displayed a
   line number.  */

static bool line_number_displayed;

/* The name of the *Messages* buffer, a string.  */

static Lisp_Object Vmessages_buffer_name;

/* Current, index 0, and last displayed echo area message.  Either
   buffers from echo_buffers, or nil to indicate no message.  */

Lisp_Object echo_area_buffer[2];

/* The buffers referenced from echo_area_buffer.  */

static Lisp_Object echo_buffer[2];

/* A vector saved used in with_area_buffer to reduce consing.  */

static Lisp_Object Vwith_echo_area_save_vector;

/* True means display_echo_area should display the last echo area
   message again.  Set by redisplay_preserve_echo_area.  */

static bool display_last_displayed_message_p;

/* True if echo area is being used by print; false if being used by
   message.  */

static bool message_buf_print;

/* Set to true in clear_message to make redisplay_internal aware
   of an emptied echo area.  */

static bool message_cleared_p;

/* A scratch glyph row with contents used for generating truncation
   glyphs.  Also used in direct_output_for_insert.  */

#define MAX_SCRATCH_GLYPHS 100
static struct glyph_row scratch_glyph_row;
static struct glyph scratch_glyphs[MAX_SCRATCH_GLYPHS];

/* Ascent and height of the last line processed by move_it_to.  */

static int last_height;

/* True if there's a help-echo in the echo area.  */

bool help_echo_showing_p;

/* The maximum distance to look ahead for text properties.  Values
   that are too small let us call compute_char_face and similar
   functions too often which is expensive.  Values that are too large
   let us call compute_char_face and alike too often because we
   might not be interested in text properties that far away.  */

#define TEXT_PROP_DISTANCE_LIMIT 100

/* SAVE_IT and RESTORE_IT are called when we save a snapshot of the
   iterator state and later restore it.  This is needed because the
   bidi iterator on bidi.c keeps a stacked cache of its states, which
   is really a singleton.  When we use scratch iterator objects to
   move around the buffer, we can cause the bidi cache to be pushed or
   popped, and therefore we need to restore the cache state when we
   return to the original iterator.  */
#define SAVE_IT(ITCOPY, ITORIG, CACHE)		\
  do {						\
    if (CACHE)					\
      bidi_unshelve_cache (CACHE, true);	\
    ITCOPY = ITORIG;				\
    CACHE = bidi_shelve_cache ();		\
  } while (false)

#define RESTORE_IT(pITORIG, pITCOPY, CACHE)	\
  do {						\
    if (pITORIG != pITCOPY)			\
      *(pITORIG) = *(pITCOPY);			\
    bidi_unshelve_cache (CACHE, false);		\
    CACHE = NULL;				\
  } while (false)

/* Functions to mark elements as needing redisplay.  */
enum { REDISPLAY_SOME = 2};	/* Arbitrary choice.  */

void
redisplay_other_windows (void)
{
  if (!windows_or_buffers_changed)
    windows_or_buffers_changed = REDISPLAY_SOME;
}

void
wset_redisplay (struct window *w)
{
  /* Beware: selected_window can be nil during early stages.  */
  if (!EQ (make_lisp_ptr (w, Lisp_Vectorlike), selected_window))
    redisplay_other_windows ();
  w->redisplay = true;
}

void
fset_redisplay (struct frame *f)
{
  redisplay_other_windows ();
  f->redisplay = true;
}

void
bset_redisplay (struct buffer *b)
{
  int count = buffer_window_count (b);
  if (count > 0)
    {
      /* ... it's visible in other window than selected,  */
      if (count > 1 || b != XBUFFER (XWINDOW (selected_window)->contents))
	redisplay_other_windows ();
      /* Even if we don't set windows_or_buffers_changed, do set `redisplay'
	 so that if we later set windows_or_buffers_changed, this buffer will
	 not be omitted.  */
      b->text->redisplay = true;
    }
}

void
bset_update_mode_line (struct buffer *b)
{
  if (!update_mode_lines)
    update_mode_lines = REDISPLAY_SOME;
  b->text->redisplay = true;
}

DEFUN ("set-buffer-redisplay", Fset_buffer_redisplay,
       Sset_buffer_redisplay, 4, 4, 0,
       doc: /* Mark the current buffer for redisplay.
This function may be passed to `add-variable-watcher'.  */)
  (Lisp_Object symbol, Lisp_Object newval, Lisp_Object op, Lisp_Object where)
{
  bset_update_mode_line (current_buffer);
  current_buffer->prevent_redisplay_optimizations_p = true;
  return Qnil;
}

/* redisplay_trace is for displaying traces of redisplay.
   If Emacs was compiled with GLYPH_DEBUG defined, the variable
   trace_redisplay_p can be set to a non-zero value in debugging
   sessions to activate traces.  */
#ifdef GLYPH_DEBUG
extern bool trace_redisplay_p EXTERNALLY_VISIBLE;
bool trace_redisplay_p;
#else
enum { trace_redisplay_p = false };
#endif
static void ATTRIBUTE_FORMAT_PRINTF (1, 2)
redisplay_trace (char const *fmt, ...)
{
  if (trace_redisplay_p)
    {
      va_list ap;
      va_start (ap, fmt);
      vprintf (fmt, ap);
      va_end (ap);
    }
}

#ifdef DEBUG_TRACE_MOVE
extern bool trace_move EXTERNALLY_VISIBLE;
bool trace_move;
#else
enum { trace_move = false };
#endif
static void ATTRIBUTE_FORMAT_PRINTF (1, 2)
move_trace (char const *fmt, ...)
{
  if (trace_move)
    {
      va_list ap;
      va_start (ap, fmt);
      vprintf (fmt, ap);
      va_end (ap);
    }
}

/* Buffer being redisplayed -- for redisplay_window_error.  */

static struct buffer *displayed_buffer;

/* Value returned from text property handlers (see below).  */

enum prop_handled
{
  HANDLED_NORMALLY,
  HANDLED_RECOMPUTE_PROPS,
  HANDLED_OVERLAY_STRING_CONSUMED,
  HANDLED_RETURN
};

/* A description of text properties that redisplay is interested
   in.  */

struct props
{
  /* The symbol index of the name of the property.  */
  short name;

  /* A unique index for the property.  */
  enum prop_idx idx;

  /* A handler function called to set up iterator IT from the property
     at IT's current position.  Value is used to steer handle_stop.  */
  enum prop_handled (*handler) (struct it *it);
};

static enum prop_handled handle_face_prop (struct it *);
static enum prop_handled handle_invisible_prop (struct it *);
static enum prop_handled handle_display_prop (struct it *);
static enum prop_handled handle_composition_prop (struct it *);
static enum prop_handled handle_overlay_change (struct it *);
static enum prop_handled handle_fontified_prop (struct it *);

/* Properties handled by iterators.  */

static struct props it_props[] =
{
  {SYMBOL_INDEX (Qfontified),	FONTIFIED_PROP_IDX,	handle_fontified_prop},
  /* Handle `face' before `display' because some sub-properties of
     `display' need to know the face.  */
  {SYMBOL_INDEX (Qface),	FACE_PROP_IDX,		handle_face_prop},
  {SYMBOL_INDEX (Qdisplay),	DISPLAY_PROP_IDX,	handle_display_prop},
  {SYMBOL_INDEX (Qinvisible),	INVISIBLE_PROP_IDX,	handle_invisible_prop},
  {SYMBOL_INDEX (Qcomposition),	COMPOSITION_PROP_IDX, handle_composition_prop},
  {0,				0,			NULL}
};

/* Enumeration returned by some move_it_.* functions internally.  */

enum move_it_result
{
  /* Not used.  Undefined value.  */
  MOVE_UNDEFINED,

  /* Move ended at the requested buffer position or ZV.  */
  MOVE_POS_MATCH_OR_ZV,

  /* Move ended at the requested X pixel position.  */
  MOVE_X_REACHED,

  /* Move within a line ended at the end of a line that must be
     continued.  */
  MOVE_LINE_CONTINUED,

  /* Move within a line ended at the end of a line that would
     be displayed truncated.  */
  MOVE_LINE_TRUNCATED,

  /* Move within a line ended at a line end.  */
  MOVE_NEWLINE_OR_CR
};

/* This counter is used to clear the face cache every once in a while
   in redisplay_internal.  It is incremented for each redisplay.
   Every CLEAR_FACE_CACHE_COUNT full redisplays, the face cache is
   cleared.  */

#define CLEAR_FACE_CACHE_COUNT	500
static int clear_face_cache_count;

/* Similarly for the image cache.  */

#ifdef HAVE_WINDOW_SYSTEM
#define CLEAR_IMAGE_CACHE_COUNT	101
static int clear_image_cache_count;

/* Null glyph slice */
static struct glyph_slice null_glyph_slice = { 0, 0, 0, 0 };
#endif

/* True while redisplay_internal is in progress.  */

bool redisplaying_p;

/* If a string, XTread_socket generates an event to display that string.
   (The display is done in read_char.)  */

Lisp_Object help_echo_string;
Lisp_Object help_echo_window;
Lisp_Object help_echo_object;
ptrdiff_t help_echo_pos;

/* Temporary variable for XTread_socket.  */

Lisp_Object previous_help_echo_string;

/* Platform-independent portion of hourglass implementation.  */

#ifdef HAVE_WINDOW_SYSTEM

/* True means an hourglass cursor is currently shown.  */
static bool hourglass_shown_p;

/* If non-null, an asynchronous timer that, when it expires, displays
   an hourglass cursor on all frames.  */
static struct atimer *hourglass_atimer;

#endif /* HAVE_WINDOW_SYSTEM */

/* Default number of seconds to wait before displaying an hourglass
   cursor.  */
#define DEFAULT_HOURGLASS_DELAY 1

#ifdef HAVE_WINDOW_SYSTEM

/* Default pixel width of `thin-space' display method.  */
#define THIN_SPACE_WIDTH 1

#endif /* HAVE_WINDOW_SYSTEM */

/* Function prototypes.  */

static void setup_for_ellipsis (struct it *, int);
static void set_iterator_to_next (struct it *, bool);
static void mark_window_display_accurate_1 (struct window *, bool);
static bool row_for_charpos_p (struct glyph_row *, ptrdiff_t);
static bool cursor_row_p (struct glyph_row *);
static int redisplay_mode_lines (Lisp_Object, bool);

static void handle_line_prefix (struct it *);

static void handle_stop_backwards (struct it *, ptrdiff_t);
static void unwind_with_echo_area_buffer (Lisp_Object);
static Lisp_Object with_echo_area_buffer_unwind_data (struct window *);
static bool current_message_1 (ptrdiff_t, Lisp_Object);
static bool truncate_message_1 (ptrdiff_t, Lisp_Object);
static void set_message (Lisp_Object);
static bool set_message_1 (ptrdiff_t, Lisp_Object);
static bool display_echo_area_1 (ptrdiff_t, Lisp_Object);
static bool resize_mini_window_1 (ptrdiff_t, Lisp_Object);
static void unwind_redisplay (void);
static void extend_face_to_end_of_line (struct it *);
static intmax_t message_log_check_duplicate (ptrdiff_t, ptrdiff_t);
static void push_it (struct it *, struct text_pos *);
static void iterate_out_of_display_property (struct it *);
static void pop_it (struct it *);
static void redisplay_internal (void);
static void echo_area_display (bool);
static void block_buffer_flips (void);
static void unblock_buffer_flips (void);
static void redisplay_windows (Lisp_Object);
static void redisplay_window (Lisp_Object, bool);
static Lisp_Object redisplay_window_error (Lisp_Object);
static Lisp_Object redisplay_window_0 (Lisp_Object);
static Lisp_Object redisplay_window_1 (Lisp_Object);
static bool set_cursor_from_row (struct window *, struct glyph_row *,
				 struct glyph_matrix *, ptrdiff_t, ptrdiff_t,
				 int, int);
static bool cursor_row_fully_visible_p (struct window *, bool, bool, bool);
static bool update_menu_bar (struct frame *, bool, bool);
static bool try_window_reusing_current_matrix (struct window *);
static int try_window_id (struct window *);
static void maybe_produce_line_number (struct it *);
static bool should_produce_line_number (struct it *);
static bool display_line (struct it *, int);
static int display_mode_lines (struct window *);
static int display_mode_line (struct window *, enum face_id, Lisp_Object);
static int display_mode_element (struct it *, int, int, int, Lisp_Object,
				 Lisp_Object, bool);
static int store_mode_line_string (const char *, Lisp_Object, bool, int, int,
				   Lisp_Object);
static const char *decode_mode_spec (struct window *, int, int, Lisp_Object *);
static void display_menu_bar (struct window *);
static void display_tab_bar (struct window *);
static void update_tab_bar (struct frame *, bool);
static ptrdiff_t display_count_lines (ptrdiff_t, ptrdiff_t, ptrdiff_t,
				      ptrdiff_t *);
static void pint2str (register char *, register int, register ptrdiff_t);

static int display_string (const char *, Lisp_Object, Lisp_Object,
                           ptrdiff_t, ptrdiff_t, struct it *, int, int, int, int);
static void compute_line_metrics (struct it *);
static void run_redisplay_end_trigger_hook (struct it *);
static bool get_overlay_strings (struct it *, ptrdiff_t);
static bool get_overlay_strings_1 (struct it *, ptrdiff_t, bool);
static void next_overlay_string (struct it *);
static void reseat (struct it *, struct text_pos, bool);
static void reseat_1 (struct it *, struct text_pos, bool);
static bool next_element_from_display_vector (struct it *);
static bool next_element_from_string (struct it *);
static bool next_element_from_c_string (struct it *);
static bool next_element_from_buffer (struct it *);
static bool next_element_from_composition (struct it *);
static bool next_element_from_image (struct it *);
static bool next_element_from_stretch (struct it *);
static bool next_element_from_xwidget (struct it *);
static void load_overlay_strings (struct it *, ptrdiff_t);
static bool get_next_display_element (struct it *);
static enum move_it_result
       move_it_in_display_line_to (struct it *, ptrdiff_t, int,
				   enum move_operation_enum);
static void get_visually_first_element (struct it *);
static void compute_stop_pos (struct it *);
static int face_before_or_after_it_pos (struct it *, bool);
static ptrdiff_t next_overlay_change (ptrdiff_t);
static int handle_display_spec (struct it *, Lisp_Object, Lisp_Object,
				Lisp_Object, struct text_pos *, ptrdiff_t, bool);
static int handle_single_display_spec (struct it *, Lisp_Object, Lisp_Object,
				       Lisp_Object, struct text_pos *,
				       ptrdiff_t, int, bool, bool);
static int underlying_face_id (const struct it *);

#define face_before_it_pos(IT) face_before_or_after_it_pos (IT, true)
#define face_after_it_pos(IT)  face_before_or_after_it_pos (IT, false)

#ifdef HAVE_WINDOW_SYSTEM

static void update_tool_bar (struct frame *, bool);
static void gui_draw_bottom_divider (struct window *w);
static void notice_overwritten_cursor (struct window *,
                                       enum glyph_row_area,
                                       int, int, int, int);
static int  normal_char_height (struct font *, int);
static void normal_char_ascent_descent (struct font *, int, int *, int *);

static void append_stretch_glyph (struct it *, Lisp_Object,
                                  int, int, int);

static Lisp_Object get_it_property (struct it *, Lisp_Object);
static Lisp_Object calc_line_height_property (struct it *, Lisp_Object,
					      struct font *, int, bool);

#endif /* HAVE_WINDOW_SYSTEM */

static void produce_special_glyphs (struct it *, enum display_element_type);
static void show_mouse_face (Mouse_HLInfo *, enum draw_glyphs_face);
static bool coords_in_mouse_face_p (struct window *, int, int);
static void reset_box_start_end_flags (struct it *);



/***********************************************************************
		      Window display dimensions
 ***********************************************************************/

/* Return the bottom boundary y-position for text lines in window W.
   This is the first y position at which a line cannot start.
   It is relative to the top of the window.

   This is the height of W minus the height of a mode line, if any.  */

int
window_text_bottom_y (struct window *w)
{
  int height = WINDOW_PIXEL_HEIGHT (w);

  height -= WINDOW_BOTTOM_DIVIDER_WIDTH (w);

  if (window_wants_mode_line (w))
    height -= CURRENT_MODE_LINE_HEIGHT (w);

  height -= WINDOW_SCROLL_BAR_AREA_HEIGHT (w);

  return height;
}

/* Return the pixel width of display area AREA of window W.
   ANY_AREA means return the total width of W, not including
   fringes to the left and right of the window.  */

int
window_box_width (struct window *w, enum glyph_row_area area)
{
  int width = w->pixel_width;

  if (!w->pseudo_window_p)
    {
      width -= WINDOW_SCROLL_BAR_AREA_WIDTH (w);
      width -= WINDOW_RIGHT_DIVIDER_WIDTH (w);

      if (area == TEXT_AREA)
	width -= (WINDOW_MARGINS_WIDTH (w)
		   + WINDOW_FRINGES_WIDTH (w));
      else if (area == LEFT_MARGIN_AREA)
	width = WINDOW_LEFT_MARGIN_WIDTH (w);
      else if (area == RIGHT_MARGIN_AREA)
	width = WINDOW_RIGHT_MARGIN_WIDTH (w);
    }

  /* With wide margins, fringes, etc. we might end up with a negative
     width, correct that here.  */
  return max (0, width);
}


/* Return the pixel height of the display area of window W, not
   including mode lines of W, if any.  */

int
window_box_height (struct window *w)
{
  struct frame *f = XFRAME (w->frame);
  int height = WINDOW_PIXEL_HEIGHT (w);

  eassert (height >= 0);

  height -= WINDOW_BOTTOM_DIVIDER_WIDTH (w);
  height -= WINDOW_SCROLL_BAR_AREA_HEIGHT (w);

  /* Note: the code below that determines the mode-line/header-line/tab-line
     height is essentially the same as that contained in the macro
     CURRENT_{MODE,HEADER,TAB}_LINE_HEIGHT, except that it checks whether
     the appropriate glyph row has its `mode_line_p' flag set, and if
     it doesn't, uses estimate_mode_line_height instead.  */

  if (window_wants_mode_line (w))
    {
      if (w->mode_line_height >= 0)
	height -= w->mode_line_height;
      else
	{
	  struct glyph_row *ml_row
	    = (w->current_matrix && w->current_matrix->rows
	       ? MATRIX_MODE_LINE_ROW (w->current_matrix)
	       : 0);
	  if (ml_row && ml_row->mode_line_p)
	    height -= ml_row->height;
	  else
	    height -= estimate_mode_line_height (f,
						 CURRENT_MODE_LINE_FACE_ID (w));
	}
    }

  if (window_wants_tab_line (w))
    {
      if (w->tab_line_height >= 0)
	height -= w->tab_line_height;
      else
	{
	  struct glyph_row *tl_row
	    = (w->current_matrix && w->current_matrix->rows
	       ? MATRIX_TAB_LINE_ROW (w->current_matrix)
	       : 0);
	  if (tl_row && tl_row->mode_line_p)
	    height -= tl_row->height;
	  else
	    height -= estimate_mode_line_height (f, TAB_LINE_FACE_ID);
	}
    }

  if (window_wants_header_line (w))
    {
      if (w->header_line_height >= 0)
	height -= w->header_line_height;
      else
	{
	  struct glyph_row *hl_row
	    = (w->current_matrix && w->current_matrix->rows
	       ? MATRIX_HEADER_LINE_ROW (w->current_matrix)
	       : 0);
	  if (hl_row && hl_row->mode_line_p)
	    height -= hl_row->height;
	  else
	    height -= estimate_mode_line_height (f, HEADER_LINE_FACE_ID);
	}
    }

  /* With a very small font and a mode-line that's taller than
     default, we might end up with a negative height.  */
  return max (0, height);
}

/* Return the window-relative coordinate of the left edge of display
   area AREA of window W.  ANY_AREA means return the left edge of the
   whole window, to the right of the left fringe of W.  */

int
window_box_left_offset (struct window *w, enum glyph_row_area area)
{
  int x;

  if (w->pseudo_window_p)
    return 0;

  x = WINDOW_LEFT_SCROLL_BAR_AREA_WIDTH (w);

  if (area == TEXT_AREA)
    x += (WINDOW_LEFT_FRINGE_WIDTH (w)
	  + window_box_width (w, LEFT_MARGIN_AREA));
  else if (area == RIGHT_MARGIN_AREA)
    x += (WINDOW_LEFT_FRINGE_WIDTH (w)
	  + window_box_width (w, LEFT_MARGIN_AREA)
	  + window_box_width (w, TEXT_AREA)
	  + (WINDOW_HAS_FRINGES_OUTSIDE_MARGINS (w)
	     ? 0
	     : WINDOW_RIGHT_FRINGE_WIDTH (w)));
  else if (area == LEFT_MARGIN_AREA
	   && WINDOW_HAS_FRINGES_OUTSIDE_MARGINS (w))
    x += WINDOW_LEFT_FRINGE_WIDTH (w);

  /* Don't return more than the window's pixel width.  */
  return min (x, w->pixel_width);
}


/* Return the window-relative coordinate of the right edge of display
   area AREA of window W.  ANY_AREA means return the right edge of the
   whole window, to the left of the right fringe of W.  */

static int
window_box_right_offset (struct window *w, enum glyph_row_area area)
{
  /* Don't return more than the window's pixel width.  */
  return min (window_box_left_offset (w, area) + window_box_width (w, area),
	      w->pixel_width);
}

/* Return the frame-relative coordinate of the left edge of display
   area AREA of window W.  ANY_AREA means return the left edge of the
   whole window, to the right of the left fringe of W.  */

int
window_box_left (struct window *w, enum glyph_row_area area)
{
  struct frame *f = XFRAME (w->frame);
  int x;

  if (w->pseudo_window_p)
    return FRAME_INTERNAL_BORDER_WIDTH (f);

  x = (WINDOW_LEFT_EDGE_X (w)
       + window_box_left_offset (w, area));

  return x;
}


/* Return the frame-relative coordinate of the right edge of display
   area AREA of window W.  ANY_AREA means return the right edge of the
   whole window, to the left of the right fringe of W.  */

int
window_box_right (struct window *w, enum glyph_row_area area)
{
  return window_box_left (w, area) + window_box_width (w, area);
}

/* Get the bounding box of the display area AREA of window W, without
   mode lines, in frame-relative coordinates.  ANY_AREA means the
   whole window, not including the left and right fringes of
   the window.  Return in *BOX_X and *BOX_Y the frame-relative pixel
   coordinates of the upper-left corner of the box.  Return in
   *BOX_WIDTH, and *BOX_HEIGHT the pixel width and height of the box.  */

void
window_box (struct window *w, enum glyph_row_area area, int *box_x,
	    int *box_y, int *box_width, int *box_height)
{
  if (box_width)
    *box_width = window_box_width (w, area);
  if (box_height)
    *box_height = window_box_height (w);
  if (box_x)
    *box_x = window_box_left (w, area);
  if (box_y)
    {
      *box_y = WINDOW_TOP_EDGE_Y (w);
      if (window_wants_tab_line (w))
	*box_y += CURRENT_TAB_LINE_HEIGHT (w);
      if (window_wants_header_line (w))
	*box_y += CURRENT_HEADER_LINE_HEIGHT (w);
    }
}

#ifdef HAVE_WINDOW_SYSTEM

/* Get the bounding box of the display area AREA of window W, without
   mode lines and both fringes of the window.  Return in *TOP_LEFT_X
   and TOP_LEFT_Y the frame-relative pixel coordinates of the
   upper-left corner of the box.  Return in *BOTTOM_RIGHT_X, and
   *BOTTOM_RIGHT_Y the coordinates of the bottom-right corner of the
   box.  */

static void
window_box_edges (struct window *w, int *top_left_x, int *top_left_y,
		  int *bottom_right_x, int *bottom_right_y)
{
  window_box (w, ANY_AREA, top_left_x, top_left_y,
	      bottom_right_x, bottom_right_y);
  *bottom_right_x += *top_left_x;
  *bottom_right_y += *top_left_y;
}

#endif /* HAVE_WINDOW_SYSTEM */

/***********************************************************************
			      Utilities
 ***********************************************************************/

/* Return the bottom y-position of the line the iterator IT is in.
   This can modify IT's settings.  */

int
line_bottom_y (struct it *it)
{
  int line_height = it->max_ascent + it->max_descent;
  int line_top_y = it->current_y;

  if (line_height == 0)
    {
      if (last_height)
	line_height = last_height;
      else if (IT_CHARPOS (*it) < ZV)
	{
	  move_it_by_lines (it, 1);
	  line_height = (it->max_ascent || it->max_descent
			 ? it->max_ascent + it->max_descent
			 : last_height);
	}
      else
	{
	  struct glyph_row *row = it->glyph_row;

	  /* Use the default character height.  */
	  it->glyph_row = NULL;
	  it->what = IT_CHARACTER;
	  it->c = ' ';
	  it->len = 1;
	  PRODUCE_GLYPHS (it);
	  line_height = it->ascent + it->descent;
	  it->glyph_row = row;
	}
    }

  return line_top_y + line_height;
}

DEFUN ("line-pixel-height", Fline_pixel_height,
       Sline_pixel_height, 0, 0, 0,
       doc: /* Return height in pixels of text line in the selected window.

Value is the height in pixels of the line at point.  */)
  (void)
{
  struct it it;
  struct text_pos pt;
  struct window *w = XWINDOW (selected_window);
  struct buffer *old_buffer = NULL;
  Lisp_Object result;

  if (XBUFFER (w->contents) != current_buffer)
    {
      old_buffer = current_buffer;
      set_buffer_internal_1 (XBUFFER (w->contents));
    }
  SET_TEXT_POS (pt, PT, PT_BYTE);
  start_display (&it, w, pt);
  /* Start from the beginning of the screen line, to make sure we
     traverse all of its display elements, and thus capture the
     correct metrics.  */
  move_it_by_lines (&it, 0);
  it.vpos = it.current_y = 0;
  last_height = 0;
  result = make_fixnum (line_bottom_y (&it));
  if (old_buffer)
    set_buffer_internal_1 (old_buffer);

  return result;
}

/* Return the default pixel height of text lines in window W.  The
   value is the canonical height of the W frame's default font, plus
   any extra space required by the line-spacing variable or frame
   parameter.

   Implementation note: this ignores any line-spacing text properties
   put on the newline characters.  This is because those properties
   only affect the _screen_ line ending in the newline (i.e., in a
   continued line, only the last screen line will be affected), which
   means only a small number of lines in a buffer can ever use this
   feature.  Since this function is used to compute the default pixel
   equivalent of text lines in a window, we can safely ignore those
   few lines.  For the same reasons, we ignore the line-height
   properties.  */
int
default_line_pixel_height (struct window *w)
{
  struct frame *f = WINDOW_XFRAME (w);
  int height = FRAME_LINE_HEIGHT (f);

  if (!FRAME_INITIAL_P (f) && BUFFERP (w->contents))
    {
      struct buffer *b = XBUFFER (w->contents);
      Lisp_Object val = BVAR (b, extra_line_spacing);

      if (NILP (val))
	val = BVAR (&buffer_defaults, extra_line_spacing);
      if (!NILP (val))
	{
	  if (RANGED_FIXNUMP (0, val, INT_MAX))
	    height += XFIXNAT (val);
	  else if (FLOATP (val))
	    {
	      int addon = XFLOAT_DATA (val) * height + 0.5;

	      if (addon >= 0)
		height += addon;
	    }
	}
      else
	height += f->extra_line_spacing;
    }

  return height;
}

/* Subroutine of pos_visible_p below.  Extracts a display string, if
   any, from the display spec given as its argument.  */
static Lisp_Object
string_from_display_spec (Lisp_Object spec)
{
  if (VECTORP (spec))
    {
      for (ptrdiff_t i = 0; i < ASIZE (spec); i++)
	if (STRINGP (AREF (spec, i)))
	  return AREF (spec, i);
    }
  else
    {
      for (; CONSP (spec); spec = XCDR (spec))
	if (STRINGP (XCAR (spec)))
	  return XCAR (spec);
    }
  return spec;
}


/* Limit insanely large values of W->hscroll on frame F to the largest
   value that will still prevent first_visible_x and last_visible_x of
   'struct it' from overflowing an int.  */
static int
window_hscroll_limited (struct window *w, struct frame *f)
{
  ptrdiff_t window_hscroll = w->hscroll;
  int window_text_width = window_box_width (w, TEXT_AREA);
  int colwidth = FRAME_COLUMN_WIDTH (f);

  if (window_hscroll > (INT_MAX - window_text_width) / colwidth - 1)
    window_hscroll = (INT_MAX - window_text_width) / colwidth - 1;

  return window_hscroll;
}

/* Reset the box-face start and end flags in the iterator.  This is
   called after producing glyphs, such that we reset these flags only
   after producing a glyph with the flag set.  */

static void
reset_box_start_end_flags (struct it *it)
{
  /* Don't reset if we've drawn the glyph in the display margins --
     those don't count as "produced glyphs".  */
  if (it->area == TEXT_AREA
      /* Don't reset if we displayed a fringe bitmap.  */
      && !(it->what == IT_IMAGE && it->image_id < 0))
    {
      /* Don't reset if the face is not a box face: that might mean we
	 are iterating some overlay or display string, and the first
	 character to have the box face is yet to be seen, when we pop
	 the iterator stack. */
      if (it->face_box_p)
	it->start_of_box_run_p = false;
      it->end_of_box_run_p = false;
    }
}

/* Return true if position CHARPOS is visible in window W.
   CHARPOS < 0 means return info about WINDOW_END position.
   If visible, set *X and *Y to pixel coordinates of top left corner.
   Set *RTOP and *RBOT to pixel height of an invisible area of glyph at POS.
   Set *ROWH and *VPOS to row's visible height and VPOS (row number).  */

bool
pos_visible_p (struct window *w, ptrdiff_t charpos, int *x, int *y,
	       int *rtop, int *rbot, int *rowh, int *vpos)
{
  struct it it;
  void *itdata = bidi_shelve_cache ();
  struct text_pos top;
  bool visible_p = false;
  struct buffer *old_buffer = NULL;
  bool r2l = false;

  if (FRAME_INITIAL_P (XFRAME (WINDOW_FRAME (w))))
    return visible_p;

  if (XBUFFER (w->contents) != current_buffer)
    {
      old_buffer = current_buffer;
      set_buffer_internal_1 (XBUFFER (w->contents));
    }

  SET_TEXT_POS_FROM_MARKER (top, w->start);
  /* Scrolling a minibuffer window via scroll bar when the echo area
     shows long text sometimes resets the minibuffer contents behind
     our backs.  Also, someone might narrow-to-region and immediately
     call a scroll function.  */
  if (CHARPOS (top) > ZV || CHARPOS (top) < BEGV)
    SET_TEXT_POS (top, BEGV, BEGV_BYTE);

  /* If the top of the window is after CHARPOS, the latter is surely
     not visible.  */
  if (charpos >= 0 && CHARPOS (top) > charpos)
    return visible_p;

  /* Some Lisp hook could call us in the middle of redisplaying this
     very window.  If, by some bad luck, we are retrying redisplay
     because we found that the mode-line height and/or tab/header-line
     height needs to be updated, the assignment of mode_line_height
     and header_line_height below could disrupt that, due to the
     selected/nonselected window dance during mode-line display, and
     we could infloop.  Avoid that.  */
  int prev_mode_line_height = w->mode_line_height;
  int prev_header_line_height = w->header_line_height;
  int prev_tab_line_height = w->tab_line_height;
  /* Compute exact mode line heights.  */
  if (window_wants_mode_line (w))
    {
      Lisp_Object window_mode_line_format
	= window_parameter (w, Qmode_line_format);

      w->mode_line_height
	= display_mode_line (w, CURRENT_MODE_LINE_FACE_ID (w),
			     NILP (window_mode_line_format)
			     ? BVAR (current_buffer, mode_line_format)
			     : window_mode_line_format);
    }

  if (window_wants_tab_line (w))
    {
      Lisp_Object window_tab_line_format
	= window_parameter (w, Qtab_line_format);

      w->tab_line_height
	= display_mode_line (w, TAB_LINE_FACE_ID,
			     NILP (window_tab_line_format)
			     ? BVAR (current_buffer, tab_line_format)
			     : window_tab_line_format);
    }

  if (window_wants_header_line (w))
    {
      Lisp_Object window_header_line_format
	= window_parameter (w, Qheader_line_format);

      w->header_line_height
	= display_mode_line (w, HEADER_LINE_FACE_ID,
			     NILP (window_header_line_format)
			     ? BVAR (current_buffer, header_line_format)
			     : window_header_line_format);
    }

  start_display (&it, w, top);
  move_it_to (&it, charpos, -1, it.last_visible_y - 1, -1,
	      (charpos >= 0 ? MOVE_TO_POS : 0) | MOVE_TO_Y);

  /* Adjust for line numbers, if CHARPOS is at or beyond first_visible_x,
     but we didn't yet produce the line-number glyphs.  */
  if (!NILP (Vdisplay_line_numbers)
      && it.current_x >= it.first_visible_x
      && IT_CHARPOS (it) == charpos
      && !it.line_number_produced_p)
    {
      /* If the pixel width of line numbers was not yet known, compute
	 it now.  This usually happens in the first display line of a
	 window.  */
      if (!it.lnum_pixel_width)
	{
	  struct it it2;
	  void *it2data = NULL;

	  SAVE_IT (it2, it, it2data);
	  move_it_by_lines (&it, 1);
	  it2.lnum_pixel_width = it.lnum_pixel_width;
	  RESTORE_IT (&it, &it2, it2data);
	}
      it.current_x += it.lnum_pixel_width;
    }

  if (charpos >= 0
      && (((!it.bidi_p || it.bidi_it.scan_dir != -1)
	   && IT_CHARPOS (it) >= charpos)
	  /* When scanning backwards under bidi iteration, move_it_to
	     stops at or _before_ CHARPOS, because it stops at or to
	     the _right_ of the character at CHARPOS.  */
	  || (it.bidi_p && it.bidi_it.scan_dir == -1
	      && IT_CHARPOS (it) <= charpos)))
    {
      /* We have reached CHARPOS, or passed it.  How the call to
	 move_it_to can overshoot: (i) If CHARPOS is on invisible text
	 or covered by a display property, move_it_to stops at the end
	 of the invisible text, to the right of CHARPOS.  (ii) If
	 CHARPOS is in a display vector, move_it_to stops on its last
	 glyph.  */
      int top_x = it.current_x;
      int top_y = it.current_y;
      int window_top_y = WINDOW_TAB_LINE_HEIGHT (w) + WINDOW_HEADER_LINE_HEIGHT (w);
      int bottom_y;
      struct it save_it;
      void *save_it_data = NULL;

      /* Calling line_bottom_y may change it.method, it.position, etc.  */
      SAVE_IT (save_it, it, save_it_data);
      last_height = 0;
      bottom_y = line_bottom_y (&it);
      if (top_y < window_top_y)
	visible_p = bottom_y > window_top_y;
      else if (top_y < it.last_visible_y)
	visible_p = true;
      if (bottom_y >= it.last_visible_y
	  && it.bidi_p && it.bidi_it.scan_dir == -1
	  && IT_CHARPOS (it) < charpos)
	{
	  /* When the last line of the window is scanned backwards
	     under bidi iteration, we could be duped into thinking
	     that we have passed CHARPOS, when in fact move_it_to
	     simply stopped short of CHARPOS because it reached
	     last_visible_y.  To see if that's what happened, we call
	     move_it_to again with a slightly larger vertical limit,
	     and see if it actually moved vertically; if it did, we
	     didn't really reach CHARPOS, which is beyond window end.  */
	  /* Why 10? because we don't know how many canonical lines
	     will the height of the next line(s) be.  So we guess.  */
	  int ten_more_lines = 10 * default_line_pixel_height (w);

	  move_it_to (&it, charpos, -1, bottom_y + ten_more_lines, -1,
		      MOVE_TO_POS | MOVE_TO_Y);
	  if (it.current_y > top_y)
	    visible_p = false;

	}
      RESTORE_IT (&it, &save_it, save_it_data);
      if (visible_p)
	{
	  if (it.method == GET_FROM_DISPLAY_VECTOR)
	    {
	      /* We stopped on the last glyph of a display vector.
		 Try and recompute.  Hack alert!  */
	      if (charpos < 2 || top.charpos >= charpos)
		top_x = it.glyph_row->x;
	      else
		{
		  struct it it2, it2_prev;
		  /* The idea is to get to the previous buffer
		     position, consume the character there, and use
		     the pixel coordinates we get after that.  But if
		     the previous buffer position is also displayed
		     from a display vector, we need to consume all of
		     the glyphs from that display vector.  */
		  start_display (&it2, w, top);
		  move_it_to (&it2, charpos - 1, -1, -1, -1, MOVE_TO_POS);
		  /* If we didn't get to CHARPOS - 1, there's some
		     replacing display property at that position, and
		     we stopped after it.  That is exactly the place
		     whose coordinates we want.  */
		  if (IT_CHARPOS (it2) != charpos - 1)
		    it2_prev = it2;
		  else
		    {
		      /* Iterate until we get out of the display
			 vector that displays the character at
			 CHARPOS - 1.  */
		      do {
			get_next_display_element (&it2);
			PRODUCE_GLYPHS (&it2);
			it2_prev = it2;
			set_iterator_to_next (&it2, true);
		      } while (it2.method == GET_FROM_DISPLAY_VECTOR
			       && IT_CHARPOS (it2) < charpos);
		    }
		  if (ITERATOR_AT_END_OF_LINE_P (&it2_prev)
		      || it2_prev.current_x > it2_prev.last_visible_x)
		    top_x = it.glyph_row->x;
		  else
		    {
		      top_x = it2_prev.current_x;
		      top_y = it2_prev.current_y;
		    }
		}
	    }
	  else if (IT_CHARPOS (it) != charpos)
	    {
	      Lisp_Object cpos = make_fixnum (charpos);
	      Lisp_Object spec = Fget_char_property (cpos, Qdisplay, Qnil);
	      Lisp_Object string = string_from_display_spec (spec);
	      struct text_pos tpos;
	      bool newline_in_string
		= (STRINGP (string)
		   && memchr (SDATA (string), '\n', SBYTES (string)));

	      SET_TEXT_POS (tpos, charpos, CHAR_TO_BYTE (charpos));
	      bool replacing_spec_p
		= (!NILP (spec)
		   && handle_display_spec (NULL, spec, Qnil, Qnil, &tpos,
					   charpos, FRAME_WINDOW_P (it.f)));
	      /* The tricky code below is needed because there's a
		 discrepancy between move_it_to and how we set cursor
		 when PT is at the beginning of a portion of text
		 covered by a display property or an overlay with a
		 display property, or the display line ends in a
		 newline from a display string.  move_it_to will stop
		 _after_ such display strings, whereas
		 set_cursor_from_row conspires with cursor_row_p to
		 place the cursor on the first glyph produced from the
		 display string.  */

	      /* We have overshoot PT because it is covered by a
		 display property that replaces the text it covers.
		 If the string includes embedded newlines, we are also
		 in the wrong display line.  Backtrack to the correct
		 line, where the display property begins.  */
	      if (replacing_spec_p)
		{
		  Lisp_Object startpos, endpos;
		  EMACS_INT start, end;
		  struct it it3;

		  /* Find the first and the last buffer positions
		     covered by the display string.  */
		  endpos =
		    Fnext_single_char_property_change (cpos, Qdisplay,
						       Qnil, Qnil);
		  startpos =
		    Fprevious_single_char_property_change (endpos, Qdisplay,
							   Qnil, Qnil);
		  start = XFIXNAT (startpos);
		  end = XFIXNAT (endpos);
		  /* Move to the last buffer position before the
		     display property.  */
		  start_display (&it3, w, top);
		  if (start > CHARPOS (top))
		    move_it_to (&it3, start - 1, -1, -1, -1, MOVE_TO_POS);
		  /* Move forward one more line if the position before
		     the display string is a newline or if it is the
		     rightmost character on a line that is
		     continued or word-wrapped.  */
		  if (it3.method == GET_FROM_BUFFER
		      && (it3.c == '\n'
			  || FETCH_BYTE (IT_BYTEPOS (it3)) == '\n'))
		    move_it_by_lines (&it3, 1);
		  else if (move_it_in_display_line_to (&it3, -1,
						       it3.current_x
						       + it3.pixel_width,
						       MOVE_TO_X)
			   == MOVE_LINE_CONTINUED)
		    {
		      move_it_by_lines (&it3, 1);
		      /* When we are under word-wrap, the #$@%!
			 move_it_by_lines moves 2 lines, so we need to
			 fix that up.  */
		      if (it3.line_wrap == WORD_WRAP)
			move_it_by_lines (&it3, -1);
		    }

		  /* Record the vertical coordinate of the display
		     line where we wound up.  */
		  top_y = it3.current_y;
		  if (it3.bidi_p)
		    {
		      /* When characters are reordered for display,
			 the character displayed to the left of the
			 display string could be _after_ the display
			 property in the logical order.  Use the
			 smallest vertical position of these two.  */
		      start_display (&it3, w, top);
		      move_it_to (&it3, end + 1, -1, -1, -1, MOVE_TO_POS);
		      if (it3.current_y < top_y)
			top_y = it3.current_y;
		    }
		  /* Move from the top of the window to the beginning
		     of the display line where the display string
		     begins.  */
		  start_display (&it3, w, top);
		  move_it_to (&it3, -1, 0, top_y, -1, MOVE_TO_X | MOVE_TO_Y);
		  /* If it3_moved stays false after the 'while' loop
		     below, that means we already were at a newline
		     before the loop (e.g., the display string begins
		     with a newline), so we don't need to (and cannot)
		     inspect the glyphs of it3.glyph_row, because
		     PRODUCE_GLYPHS will not produce anything for a
		     newline, and thus it3.glyph_row stays at its
		     stale content it got at top of the window.  */
		  bool it3_moved = false;
		  /* Finally, advance the iterator until we hit the
		     first display element whose character position is
		     CHARPOS, or until the first newline from the
		     display string, which signals the end of the
		     display line.  */
		  while (get_next_display_element (&it3))
		    {
		      PRODUCE_GLYPHS (&it3);
		      if (IT_CHARPOS (it3) == charpos
			  || ITERATOR_AT_END_OF_LINE_P (&it3))
			break;
		      it3_moved = true;
		      set_iterator_to_next (&it3, false);
		    }
		  top_x = it3.current_x - it3.pixel_width;
		  /* Account for line-number display, if IT3 still
		     didn't.  This can happen if START - 1 is the
		     first character on its display line.  */
		  if (!it3.line_number_produced_p
		      && it.line_number_produced_p)
		    top_x += it.lnum_pixel_width;
		  /* Normally, we would exit the above loop because we
		     found the display element whose character
		     position is CHARPOS.  For the contingency that we
		     didn't, and stopped at the first newline from the
		     display string, move back over the glyphs
		     produced from the string, until we find the
		     rightmost glyph not from the string.  */
		  if (it3_moved
		      && newline_in_string
		      && IT_CHARPOS (it3) != charpos && EQ (it3.object, string))
		    {
		      struct glyph *g = it3.glyph_row->glyphs[TEXT_AREA]
					+ it3.glyph_row->used[TEXT_AREA];

		      while (EQ ((g - 1)->object, string))
			{
			  --g;
			  top_x -= g->pixel_width;
			}
		      eassert (g < it3.glyph_row->glyphs[TEXT_AREA]
				    + it3.glyph_row->used[TEXT_AREA]);
		    }
		}
	    }

	  *x = top_x;
	  *y = max (top_y + max (0, it.max_ascent - it.ascent), window_top_y);
	  *rtop = max (0, window_top_y - top_y);
	  *rbot = max (0, bottom_y - it.last_visible_y);
	  *rowh = max (0, (min (bottom_y, it.last_visible_y)
			   - max (top_y, window_top_y)));
	  *vpos = it.vpos;
	  if (it.bidi_it.paragraph_dir == R2L)
	    r2l = true;
	}
    }
  else
    {
      /* Either we were asked to provide info about WINDOW_END, or
	 CHARPOS is in the partially visible glyph row at end of
	 window.  */
      struct it it2;
      void *it2data = NULL;

      SAVE_IT (it2, it, it2data);
      if (IT_CHARPOS (it) < ZV && FETCH_BYTE (IT_BYTEPOS (it)) != '\n')
	move_it_by_lines (&it, 1);
      if (charpos < IT_CHARPOS (it)
	  || (it.what == IT_EOB && charpos == IT_CHARPOS (it)))
	{
	  visible_p = true;
	  RESTORE_IT (&it2, &it2, it2data);
	  move_it_to (&it2, charpos, -1, -1, -1, MOVE_TO_POS);
	  *x = it2.current_x;
	  *y = it2.current_y + it2.max_ascent - it2.ascent;
	  *rtop = max (0, -it2.current_y);
	  *rbot = max (0, ((it2.current_y + it2.max_ascent + it2.max_descent)
			   - it.last_visible_y));
	  *rowh = max (0, (min (it2.current_y + it2.max_ascent + it2.max_descent,
				it.last_visible_y)
			   - max (max (it2.current_y,
				       WINDOW_TAB_LINE_HEIGHT (w)),
				  WINDOW_HEADER_LINE_HEIGHT (w))));
	  *vpos = it2.vpos;
	  if (it2.bidi_it.paragraph_dir == R2L)
	    r2l = true;
	}
      else
	bidi_unshelve_cache (it2data, true);
    }
  bidi_unshelve_cache (itdata, false);

  if (old_buffer)
    set_buffer_internal_1 (old_buffer);

  if (visible_p)
    {
      if (w->hscroll > 0)
	*x -=
	  window_hscroll_limited (w, WINDOW_XFRAME (w))
	  * WINDOW_FRAME_COLUMN_WIDTH (w);
      /* For lines in an R2L paragraph, we need to mirror the X pixel
         coordinate wrt the text area.  For the reasons, see the
         commentary in buffer_posn_from_coords and the explanation of
         the geometry used by the move_it_* functions at the end of
         the large commentary near the beginning of this file.  */
      if (r2l)
	*x = window_box_width (w, TEXT_AREA) - *x - 1;
    }

#if false
  /* Debugging code.  */
  if (visible_p)
    fprintf (stderr, "+pv pt=%d vs=%d --> x=%d y=%d rt=%d rb=%d rh=%d vp=%d\n",
	     charpos, w->vscroll, *x, *y, *rtop, *rbot, *rowh, *vpos);
  else
    fprintf (stderr, "-pv pt=%d vs=%d\n", charpos, w->vscroll);
#endif

  /* Restore potentially overwritten values.  */
  w->mode_line_height = prev_mode_line_height;
  w->header_line_height = prev_header_line_height;
  w->tab_line_height = prev_tab_line_height;

  return visible_p;
}


/* Return the next character from STR.  Return in *LEN the length of
   the character.  This is like STRING_CHAR_AND_LENGTH but never
   returns an invalid character.  If we find one, we return a `?', but
   with the length of the invalid character.  */

static int
string_char_and_length (const unsigned char *str, int *len)
{
  int c;

  c = STRING_CHAR_AND_LENGTH (str, *len);
  if (!CHAR_VALID_P (c))
    /* We may not change the length here because other places in Emacs
       don't use this function, i.e. they silently accept invalid
       characters.  */
    c = '?';

  return c;
}



/* Given a position POS containing a valid character and byte position
   in STRING, return the position NCHARS ahead (NCHARS >= 0).  */

static struct text_pos
string_pos_nchars_ahead (struct text_pos pos, Lisp_Object string, ptrdiff_t nchars)
{
  eassert (STRINGP (string) && nchars >= 0);

  if (STRING_MULTIBYTE (string))
    {
      const unsigned char *p = SDATA (string) + BYTEPOS (pos);
      int len;

      while (nchars--)
	{
	  string_char_and_length (p, &len);
	  p += len;
	  CHARPOS (pos) += 1;
	  BYTEPOS (pos) += len;
	}
    }
  else
    SET_TEXT_POS (pos, CHARPOS (pos) + nchars, BYTEPOS (pos) + nchars);

  return pos;
}


/* Value is the text position, i.e. character and byte position,
   for character position CHARPOS in STRING.  */

static struct text_pos
string_pos (ptrdiff_t charpos, Lisp_Object string)
{
  struct text_pos pos;
  eassert (STRINGP (string));
  eassert (charpos >= 0);
  SET_TEXT_POS (pos, charpos, string_char_to_byte (string, charpos));
  return pos;
}


/* Value is a text position, i.e. character and byte position, for
   character position CHARPOS in C string S.  MULTIBYTE_P
   means recognize multibyte characters.  */

static struct text_pos
c_string_pos (ptrdiff_t charpos, const char *s, bool multibyte_p)
{
  struct text_pos pos;

  eassert (s != NULL);
  eassert (charpos >= 0);

  if (multibyte_p)
    {
      int len;

      SET_TEXT_POS (pos, 0, 0);
      while (charpos--)
	{
	  string_char_and_length ((const unsigned char *) s, &len);
	  s += len;
	  CHARPOS (pos) += 1;
	  BYTEPOS (pos) += len;
	}
    }
  else
    SET_TEXT_POS (pos, charpos, charpos);

  return pos;
}


/* Value is the number of characters in C string S.  MULTIBYTE_P
   means recognize multibyte characters.  */

static ptrdiff_t
number_of_chars (const char *s, bool multibyte_p)
{
  ptrdiff_t nchars;

  if (multibyte_p)
    {
      ptrdiff_t rest = strlen (s);
      int len;
      const unsigned char *p = (const unsigned char *) s;

      for (nchars = 0; rest > 0; ++nchars)
	{
	  string_char_and_length (p, &len);
	  rest -= len, p += len;
	}
    }
  else
    nchars = strlen (s);

  return nchars;
}


/* Compute byte position NEWPOS->bytepos corresponding to
   NEWPOS->charpos.  POS is a known position in string STRING.
   NEWPOS->charpos must be >= POS.charpos.  */

static void
compute_string_pos (struct text_pos *newpos, struct text_pos pos, Lisp_Object string)
{
  eassert (STRINGP (string));
  eassert (CHARPOS (*newpos) >= CHARPOS (pos));

  if (STRING_MULTIBYTE (string))
    *newpos = string_pos_nchars_ahead (pos, string,
				       CHARPOS (*newpos) - CHARPOS (pos));
  else
    BYTEPOS (*newpos) = CHARPOS (*newpos);
}

/* EXPORT:
   Return an estimation of the pixel height of mode or header lines on
   frame F.  FACE_ID specifies what line's height to estimate.  */

int
estimate_mode_line_height (struct frame *f, enum face_id face_id)
{
#ifdef HAVE_WINDOW_SYSTEM
  if (FRAME_WINDOW_P (f))
    {
      int height = FONT_HEIGHT (FRAME_FONT (f));

      /* This function is called so early when Emacs starts that the face
	 cache and mode line face are not yet initialized.  */
      if (FRAME_FACE_CACHE (f))
	{
	  struct face *face = FACE_FROM_ID_OR_NULL (f, face_id);
	  if (face)
	    {
	      if (face->font)
		height = normal_char_height (face->font, -1);
	      if (face->box_horizontal_line_width > 0)
		height += 2 * face->box_horizontal_line_width;
	    }
	}

      return height;
    }
#endif

  return 1;
}

/* Given a pixel position (PIX_X, PIX_Y) on frame F, return glyph
   co-ordinates in (*X, *Y).  Set *BOUNDS to the rectangle that the
   glyph at X, Y occupies, if BOUNDS != 0.  If NOCLIP, do
   not force the value into range.  */

void
pixel_to_glyph_coords (struct frame *f, int pix_x, int pix_y, int *x, int *y,
		       NativeRectangle *bounds, bool noclip)
{

#ifdef HAVE_WINDOW_SYSTEM
  if (FRAME_WINDOW_P (f))
    {
      /* Arrange for the division in FRAME_PIXEL_X_TO_COL etc. to round down
	 even for negative values.  */
      if (pix_x < 0)
	pix_x -= FRAME_COLUMN_WIDTH (f) - 1;
      if (pix_y < 0)
	pix_y -= FRAME_LINE_HEIGHT (f) - 1;

      pix_x = FRAME_PIXEL_X_TO_COL (f, pix_x);
      pix_y = FRAME_PIXEL_Y_TO_LINE (f, pix_y);

      if (bounds)
	STORE_NATIVE_RECT (*bounds,
			   FRAME_COL_TO_PIXEL_X (f, pix_x),
			   FRAME_LINE_TO_PIXEL_Y (f, pix_y),
			   FRAME_COLUMN_WIDTH (f) - 1,
			   FRAME_LINE_HEIGHT (f) - 1);

      /* PXW: Should we clip pixels before converting to columns/lines?  */
      if (!noclip)
	{
	  if (pix_x < 0)
	    pix_x = 0;
	  else if (pix_x > FRAME_TOTAL_COLS (f))
	    pix_x = FRAME_TOTAL_COLS (f);

	  if (pix_y < 0)
	    pix_y = 0;
	  else if (pix_y > FRAME_TOTAL_LINES (f))
	    pix_y = FRAME_TOTAL_LINES (f);
	}
    }
#endif

  *x = pix_x;
  *y = pix_y;
}


/* Find the glyph under window-relative coordinates X/Y in window W.
   Consider only glyphs from buffer text, i.e. no glyphs from overlay
   strings.  Return in *HPOS and *VPOS the row and column number of
   the glyph found.  Return in *AREA the glyph area containing X.
   Value is a pointer to the glyph found or null if X/Y is not on
   text, or we can't tell because W's current matrix is not up to
   date.  */

static struct glyph *
x_y_to_hpos_vpos (struct window *w, int x, int y, int *hpos, int *vpos,
		  int *dx, int *dy, int *area)
{
  struct glyph *glyph, *end;
  struct glyph_row *row = NULL;
  int x0, i;

  /* Find row containing Y.  Give up if some row is not enabled.  */
  for (i = 0; i < w->current_matrix->nrows; ++i)
    {
      row = MATRIX_ROW (w->current_matrix, i);
      if (!row->enabled_p)
	return NULL;
      if (y >= row->y && y < MATRIX_ROW_BOTTOM_Y (row))
	break;
    }

  *vpos = i;
  *hpos = 0;

  /* Give up if Y is not in the window.  */
  if (i == w->current_matrix->nrows)
    return NULL;

  /* Get the glyph area containing X.  */
  if (w->pseudo_window_p)
    {
      *area = TEXT_AREA;
      x0 = 0;
    }
  else
    {
      if (x < window_box_left_offset (w, TEXT_AREA))
	{
	  *area = LEFT_MARGIN_AREA;
	  x0 = window_box_left_offset (w, LEFT_MARGIN_AREA);
	}
      else if (x < window_box_right_offset (w, TEXT_AREA))
	{
	  *area = TEXT_AREA;
	  x0 = window_box_left_offset (w, TEXT_AREA) + min (row->x, 0);
	}
      else
	{
	  *area = RIGHT_MARGIN_AREA;
	  x0 = window_box_left_offset (w, RIGHT_MARGIN_AREA);
	}
    }

  /* Find glyph containing X.  */
  glyph = row->glyphs[*area];
  end = glyph + row->used[*area];
  x -= x0;
  while (glyph < end && x >= glyph->pixel_width)
    {
      x -= glyph->pixel_width;
      ++glyph;
    }

  if (glyph == end)
    return NULL;

  if (dx)
    {
      *dx = x;
      *dy = y - (row->y + row->ascent - glyph->ascent);
    }

  *hpos = glyph - row->glyphs[*area];
  return glyph;
}

/* Convert frame-relative x/y to coordinates relative to window W.
   Takes pseudo-windows into account.  */

static void
frame_to_window_pixel_xy (struct window *w, int *x, int *y)
{
  if (w->pseudo_window_p)
    {
      /* A pseudo-window is always full-width, and starts at the
	 left edge of the frame, plus a frame border.  */
      struct frame *f = XFRAME (w->frame);
      *x -= FRAME_INTERNAL_BORDER_WIDTH (f);
      *y = FRAME_TO_WINDOW_PIXEL_Y (w, *y);
    }
  else
    {
      *x -= WINDOW_LEFT_EDGE_X (w);
      *y = FRAME_TO_WINDOW_PIXEL_Y (w, *y);
    }
}

#ifdef HAVE_WINDOW_SYSTEM

/* EXPORT:
   Return in RECTS[] at most N clipping rectangles for glyph string S.
   Return the number of stored rectangles.  */

int
get_glyph_string_clip_rects (struct glyph_string *s, NativeRectangle *rects, int n)
{
  Emacs_Rectangle r;

  if (n <= 0)
    return 0;

  if (s->row->full_width_p)
    {
      /* Draw full-width.  X coordinates are relative to S->w->left_col.  */
      r.x = WINDOW_LEFT_EDGE_X (s->w);
      if (s->row->mode_line_p)
	r.width = WINDOW_PIXEL_WIDTH (s->w) - WINDOW_RIGHT_DIVIDER_WIDTH (s->w);
      else
	r.width = WINDOW_PIXEL_WIDTH (s->w);

      /* Unless displaying a mode or menu bar line, which are always
	 fully visible, clip to the visible part of the row.  */
      if (s->w->pseudo_window_p)
	r.height = s->row->visible_height;
      else
	r.height = s->height;
    }
  else
    {
      /* This is a text line that may be partially visible.  */
      r.x = window_box_left (s->w, s->area);
      r.width = window_box_width (s->w, s->area);
      r.height = s->row->visible_height;
    }

  if (s->clip_head)
    if (r.x < s->clip_head->x)
      {
	if (r.width >= s->clip_head->x - r.x)
	  r.width -= s->clip_head->x - r.x;
	else
	  r.width = 0;
	r.x = s->clip_head->x;
      }
  if (s->clip_tail)
    if (r.x + r.width > s->clip_tail->x + s->clip_tail->background_width)
      {
	if (s->clip_tail->x + s->clip_tail->background_width >= r.x)
	  r.width = s->clip_tail->x + s->clip_tail->background_width - r.x;
	else
	  r.width = 0;
      }

  /* If S draws overlapping rows, it's sufficient to use the top and
     bottom of the window for clipping because this glyph string
     intentionally draws over other lines.  */
  if (s->for_overlaps)
    {
      r.y = WINDOW_TAB_LINE_HEIGHT (s->w) + WINDOW_HEADER_LINE_HEIGHT (s->w);
      r.height = window_text_bottom_y (s->w) - r.y;

      /* Alas, the above simple strategy does not work for the
	 environments with anti-aliased text: if the same text is
	 drawn onto the same place multiple times, it gets thicker.
	 If the overlap we are processing is for the erased cursor, we
	 take the intersection with the rectangle of the cursor.  */
      if (s->for_overlaps & OVERLAPS_ERASED_CURSOR)
	{
	  Emacs_Rectangle rc, r_save = r;

	  rc.x = WINDOW_TEXT_TO_FRAME_PIXEL_X (s->w, s->w->phys_cursor.x);
	  rc.y = s->w->phys_cursor.y;
	  rc.width = s->w->phys_cursor_width;
	  rc.height = s->w->phys_cursor_height;

	  gui_intersect_rectangles (&r_save, &rc, &r);
	}
    }
  else
    {
      /* Don't use S->y for clipping because it doesn't take partially
	 visible lines into account.  For example, it can be negative for
	 partially visible lines at the top of a window.  */
      if (!s->row->full_width_p
	  && MATRIX_ROW_PARTIALLY_VISIBLE_AT_TOP_P (s->w, s->row))
	r.y = WINDOW_TAB_LINE_HEIGHT (s->w) + WINDOW_HEADER_LINE_HEIGHT (s->w);
      else
	r.y = max (0, s->row->y);
    }

  r.y = WINDOW_TO_FRAME_PIXEL_Y (s->w, r.y);

  /* If drawing the cursor, don't let glyph draw outside its
     advertised boundaries. Cleartype does this under some circumstances.  */
  if (s->hl == DRAW_CURSOR)
    {
      struct glyph *glyph = s->first_glyph;
      int height, max_y;

      if (s->x > r.x)
	{
	  if (r.width >= s->x - r.x)
	    r.width -= s->x - r.x;
	  else	/* R2L hscrolled row with cursor outside text area */
	    r.width = 0;
	  r.x = s->x;
	}
      r.width = min (r.width, glyph->pixel_width);

      /* If r.y is below window bottom, ensure that we still see a cursor.  */
      height = min (glyph->ascent + glyph->descent,
		    min (FRAME_LINE_HEIGHT (s->f), s->row->visible_height));
      max_y = window_text_bottom_y (s->w) - height;
      max_y = WINDOW_TO_FRAME_PIXEL_Y (s->w, max_y);
      if (s->ybase - glyph->ascent > max_y)
	{
	  r.y = max_y;
	  r.height = height;
	}
      else
	{
	  /* Don't draw cursor glyph taller than our actual glyph.  */
	  height = max (FRAME_LINE_HEIGHT (s->f), glyph->ascent + glyph->descent);
	  if (height < r.height)
	    {
	      max_y = r.y + r.height;
	      r.y = min (max_y, max (r.y, s->ybase + glyph->descent - height));
	      r.height = min (max_y - r.y, height);
	    }
	}
    }

  if (s->row->clip)
    {
      Emacs_Rectangle r_save = r;

      if (! gui_intersect_rectangles (&r_save, s->row->clip, &r))
	r.width = 0;
    }

  if ((s->for_overlaps & OVERLAPS_BOTH) == 0
      || ((s->for_overlaps & OVERLAPS_BOTH) == OVERLAPS_BOTH && n == 1))
    {
#ifdef CONVERT_FROM_EMACS_RECT
      CONVERT_FROM_EMACS_RECT (r, *rects);
#else
      *rects = r;
#endif
      return 1;
    }
  else
    {
      /* If we are processing overlapping and allowed to return
	 multiple clipping rectangles, we exclude the row of the glyph
	 string from the clipping rectangle.  This is to avoid drawing
	 the same text on the environment with anti-aliasing.  */
#ifdef CONVERT_FROM_EMACS_RECT
      Emacs_Rectangle rs[2];
#else
      Emacs_Rectangle *rs = rects;
#endif
      int i = 0, row_y = WINDOW_TO_FRAME_PIXEL_Y (s->w, s->row->y);

      if (s->for_overlaps & OVERLAPS_PRED)
	{
	  rs[i] = r;
	  if (r.y + r.height > row_y)
	    {
	      if (r.y < row_y)
		rs[i].height = row_y - r.y;
	      else
		rs[i].height = 0;
	    }
	  i++;
	}
      if (s->for_overlaps & OVERLAPS_SUCC)
	{
	  rs[i] = r;
	  if (r.y < row_y + s->row->visible_height)
	    {
	      if (r.y + r.height > row_y + s->row->visible_height)
		{
		  rs[i].y = row_y + s->row->visible_height;
		  rs[i].height = r.y + r.height - rs[i].y;
		}
	      else
		rs[i].height = 0;
	    }
	  i++;
	}

      n = i;
#ifdef CONVERT_FROM_EMACS_RECT
      for (i = 0; i < n; i++)
	CONVERT_FROM_EMACS_RECT (rs[i], rects[i]);
#endif
      return n;
    }
}

/* EXPORT:
   Return in *NR the clipping rectangle for glyph string S.  */

void
get_glyph_string_clip_rect (struct glyph_string *s, NativeRectangle *nr)
{
  get_glyph_string_clip_rects (s, nr, 1);
}


/* EXPORT:
   Return the position and height of the phys cursor in window W.
   Set w->phys_cursor_width to width of phys cursor.
*/

void
get_phys_cursor_geometry (struct window *w, struct glyph_row *row,
			  struct glyph *glyph, int *xp, int *yp, int *heightp)
{
  struct frame *f = XFRAME (WINDOW_FRAME (w));
  int x, y, wd, h, h0, y0, ascent;

  /* Compute the width of the rectangle to draw.  If on a stretch
     glyph, and `x-stretch-cursor' is nil, don't draw a rectangle
     as wide as the glyph, but use a canonical character width
     instead.  */
  wd = glyph->pixel_width;

  x = w->phys_cursor.x;
  if (x < 0)
    {
      wd += x;
      x = 0;
    }

  if (glyph->type == STRETCH_GLYPH
      && !x_stretch_cursor_p)
    wd = min (FRAME_COLUMN_WIDTH (f), wd);
  w->phys_cursor_width = wd;

  /* Don't let the hollow cursor glyph descend below the glyph row's
     ascent value, lest the hollow cursor looks funny.  */
  y = w->phys_cursor.y;
  ascent = row->ascent;
  /* The test for row at ZV is for when line numbers are displayed and
     point is at EOB: the cursor could then be smaller or larger than
     the default face's font.  */
  if (!row->ends_at_zv_p && row->ascent < glyph->ascent)
    {
      y -= glyph->ascent - row->ascent;
      ascent = glyph->ascent;
    }

  /* If y is below window bottom, ensure that we still see a cursor.  */
  h0 = min (FRAME_LINE_HEIGHT (f), row->visible_height);

  h = max (h0, ascent + glyph->descent);
  /* Don't let the cursor exceed the dimensions of the row, so that
     the upper/lower side of the box aren't clipped.  */
  h = min (h, row->height);
  h0 = min (h0, ascent + glyph->descent);

  y0 = WINDOW_TAB_LINE_HEIGHT (w) + WINDOW_HEADER_LINE_HEIGHT (w);
  if (y < y0)
    {
      h = max (h - (y0 - y) + 1, h0);
      y = y0 - 1;
    }
  else
    {
      y0 = window_text_bottom_y (w) - h0;
      if (y > y0)
	{
	  h += y - y0;
	  y = y0;
	}
    }

  *xp = WINDOW_TEXT_TO_FRAME_PIXEL_X (w, x);
  *yp = WINDOW_TO_FRAME_PIXEL_Y (w, y);
  *heightp = h;
}

/*
 * Remember which glyph the mouse is over.
 */

void
remember_mouse_glyph (struct frame *f, int gx, int gy, NativeRectangle *rect)
{
  Lisp_Object window;
  struct window *w;
  struct glyph_row *r, *gr, *end_row;
  enum window_part part;
  enum glyph_row_area area;
  int x, y, width, height;

  if (mouse_fine_grained_tracking)
    {
      STORE_NATIVE_RECT (*rect, gx, gy, 1, 1);
      return;
    }

  /* Try to determine frame pixel position and size of the glyph under
     frame pixel coordinates X/Y on frame F.  */

  if (window_resize_pixelwise)
    {
      width = height = 1;
      goto virtual_glyph;
    }
  else if (!f->glyphs_initialized_p
	   || (window = window_from_coordinates (f, gx, gy, &part, false, false),
	       NILP (window)))
    {
      width = FRAME_SMALLEST_CHAR_WIDTH (f);
      height = FRAME_SMALLEST_FONT_HEIGHT (f);
      goto virtual_glyph;
    }

  w = XWINDOW (window);
  width = WINDOW_FRAME_COLUMN_WIDTH (w);
  height = WINDOW_FRAME_LINE_HEIGHT (w);

  x = window_relative_x_coord (w, part, gx);
  y = gy - WINDOW_TOP_EDGE_Y (w);

  r = MATRIX_FIRST_TEXT_ROW (w->current_matrix);
  end_row = MATRIX_BOTTOM_TEXT_ROW (w->current_matrix, w);

  if (w->pseudo_window_p)
    {
      area = TEXT_AREA;
      part = ON_MODE_LINE; /* Don't adjust margin. */
      goto text_glyph;
    }

  switch (part)
    {
    case ON_LEFT_MARGIN:
      area = LEFT_MARGIN_AREA;
      goto text_glyph;

    case ON_RIGHT_MARGIN:
      area = RIGHT_MARGIN_AREA;
      goto text_glyph;

    case ON_TAB_LINE:
    case ON_HEADER_LINE:
    case ON_MODE_LINE:
      gr = (part == ON_TAB_LINE
	    ? MATRIX_TAB_LINE_ROW (w->current_matrix)
	    : (part == ON_HEADER_LINE
	       ? MATRIX_HEADER_LINE_ROW (w->current_matrix)
	       : MATRIX_MODE_LINE_ROW (w->current_matrix)));
      gy = gr->y;
      area = TEXT_AREA;
      goto text_glyph_row_found;

    case ON_TEXT:
      area = TEXT_AREA;

    text_glyph:
      gr = 0; gy = 0;
      for (; r <= end_row && r->enabled_p; ++r)
	if (r->y + r->height > y)
	  {
	    gr = r; gy = r->y;
	    break;
	  }

    text_glyph_row_found:
      if (gr && gy <= y)
	{
	  struct glyph *g = gr->glyphs[area];
	  struct glyph *end = g + gr->used[area];

	  height = gr->height;
	  for (gx = gr->x; g < end; gx += g->pixel_width, ++g)
	    if (gx + g->pixel_width > x)
	      break;

	  if (g < end)
	    {
	      if (g->type == IMAGE_GLYPH)
		{
		  /* Don't remember when mouse is over image, as
		     image may have hot-spots.  */
		  STORE_NATIVE_RECT (*rect, 0, 0, 0, 0);
		  return;
		}
	      width = g->pixel_width;
	    }
	  else
	    {
	      /* Use nominal char spacing at end of line.  */
	      x -= gx;
	      gx += (x / width) * width;
	    }

	  if (part != ON_MODE_LINE && part != ON_HEADER_LINE
	      && part != ON_TAB_LINE)
	    {
	      gx += window_box_left_offset (w, area);
	      /* Don't expand over the modeline to make sure the vertical
		 drag cursor is shown early enough.  */
	      height = min (height,
			    max (0, WINDOW_BOX_HEIGHT_NO_MODE_LINE (w) - gy));
	    }
	}
      else
	{
	  /* Use nominal line height at end of window.  */
	  gx = (x / width) * width;
	  y -= gy;
	  gy += (y / height) * height;
	  if (part != ON_MODE_LINE && part != ON_HEADER_LINE
	      && part != ON_TAB_LINE)
	    /* See comment above.  */
	    height = min (height,
			  max (0, WINDOW_BOX_HEIGHT_NO_MODE_LINE (w) - gy));
	}
      break;

    case ON_LEFT_FRINGE:
      gx = (WINDOW_HAS_FRINGES_OUTSIDE_MARGINS (w)
	    ? WINDOW_LEFT_SCROLL_BAR_AREA_WIDTH (w)
	    : window_box_right_offset (w, LEFT_MARGIN_AREA));
      width = WINDOW_LEFT_FRINGE_WIDTH (w);
      goto row_glyph;

    case ON_RIGHT_FRINGE:
      gx = (WINDOW_HAS_FRINGES_OUTSIDE_MARGINS (w)
	    ? window_box_right_offset (w, RIGHT_MARGIN_AREA)
	    : window_box_right_offset (w, TEXT_AREA));
      if (WINDOW_RIGHT_DIVIDER_WIDTH (w) == 0
	  && !WINDOW_HAS_VERTICAL_SCROLL_BAR (w)
	  && !WINDOW_RIGHTMOST_P (w))
	if (gx < WINDOW_PIXEL_WIDTH (w) - width)
	  /* Make sure the vertical border can get her own glyph to the
	     right of the one we build here.  */
	  width = WINDOW_RIGHT_FRINGE_WIDTH (w) - width;
	else
	  width = WINDOW_PIXEL_WIDTH (w) - gx;
      else
	width = WINDOW_RIGHT_FRINGE_WIDTH (w);

      goto row_glyph;

    case ON_VERTICAL_BORDER:
      gx = WINDOW_PIXEL_WIDTH (w) - width;
      goto row_glyph;

    case ON_VERTICAL_SCROLL_BAR:
      gx = (WINDOW_HAS_VERTICAL_SCROLL_BAR_ON_LEFT (w)
	    ? 0
	    : (window_box_right_offset (w, RIGHT_MARGIN_AREA)
	       + (WINDOW_HAS_FRINGES_OUTSIDE_MARGINS (w)
		  ? WINDOW_RIGHT_FRINGE_WIDTH (w)
		  : 0)));
      width = WINDOW_SCROLL_BAR_AREA_WIDTH (w);

    row_glyph:
      gr = 0, gy = 0;
      for (; r <= end_row && r->enabled_p; ++r)
	if (r->y + r->height > y)
	  {
	    gr = r; gy = r->y;
	    break;
	  }

      if (gr && gy <= y)
	height = gr->height;
      else
	{
	  /* Use nominal line height at end of window.  */
	  y -= gy;
	  gy += (y / height) * height;
	}
      break;

    case ON_RIGHT_DIVIDER:
      gx = WINDOW_PIXEL_WIDTH (w) - WINDOW_RIGHT_DIVIDER_WIDTH (w);
      width = WINDOW_RIGHT_DIVIDER_WIDTH (w);
      gy = 0;
      /* The bottom divider prevails. */
      height = WINDOW_PIXEL_HEIGHT (w) - WINDOW_BOTTOM_DIVIDER_WIDTH (w);
      goto add_edge;

    case ON_BOTTOM_DIVIDER:
      gx = 0;
      width = WINDOW_PIXEL_WIDTH (w);
      gy = WINDOW_PIXEL_HEIGHT (w) - WINDOW_BOTTOM_DIVIDER_WIDTH (w);
      height = WINDOW_BOTTOM_DIVIDER_WIDTH (w);
      goto add_edge;

    default:
      ;
    virtual_glyph:
      /* If there is no glyph under the mouse, then we divide the screen
	 into a grid of the smallest glyph in the frame, and use that
	 as our "glyph".  */

      /* Arrange for the division in FRAME_PIXEL_X_TO_COL etc. to
	 round down even for negative values.  */
      if (gx < 0)
	gx -= width - 1;
      if (gy < 0)
	gy -= height - 1;

      gx = (gx / width) * width;
      gy = (gy / height) * height;

      goto store_rect;
    }

 add_edge:
  gx += WINDOW_LEFT_EDGE_X (w);
  gy += WINDOW_TOP_EDGE_Y (w);

 store_rect:
  STORE_NATIVE_RECT (*rect, gx, gy, width, height);

  /* Visible feedback for debugging.  */
#if false && defined HAVE_X_WINDOWS
  XDrawRectangle (FRAME_X_DISPLAY (f), FRAME_X_DRAWABLE (f),
		  f->output_data.x->normal_gc,
		  gx, gy, width, height);
#endif
}


#endif /* HAVE_WINDOW_SYSTEM */

static void
adjust_window_ends (struct window *w, struct glyph_row *row, bool current)
{
  eassert (w);
  w->window_end_pos = Z - MATRIX_ROW_END_CHARPOS (row);
  w->window_end_bytepos = Z_BYTE - MATRIX_ROW_END_BYTEPOS (row);
  w->window_end_vpos
    = MATRIX_ROW_VPOS (row, current ? w->current_matrix : w->desired_matrix);
}

static bool
hscrolling_current_line_p (struct window *w)
{
  return (!w->suspend_auto_hscroll
	  && EQ (Fbuffer_local_value (Qauto_hscroll_mode, w->contents),
		 Qcurrent_line));
}

/***********************************************************************
			Lisp form evaluation
 ***********************************************************************/

/* Error handler for safe_eval and safe_call.  */

static Lisp_Object
safe_eval_handler (Lisp_Object arg, ptrdiff_t nargs, Lisp_Object *args)
{
  add_to_log ("Error during redisplay: %S signaled %S",
	      Flist (nargs, args), arg);
  return Qnil;
}

/* Call function FUNC with the rest of NARGS - 1 arguments
   following.  Return the result, or nil if something went
   wrong.  Prevent redisplay during the evaluation.  */

static Lisp_Object
safe__call (bool inhibit_quit, ptrdiff_t nargs, Lisp_Object func, va_list ap)
{
  Lisp_Object val;

  if (inhibit_eval_during_redisplay)
    val = Qnil;
  else
    {
      ptrdiff_t i;
      ptrdiff_t count = SPECPDL_INDEX ();
      Lisp_Object *args;
      USE_SAFE_ALLOCA;
      SAFE_ALLOCA_LISP (args, nargs);

      args[0] = func;
      for (i = 1; i < nargs; i++)
	args[i] = va_arg (ap, Lisp_Object);

      specbind (Qinhibit_redisplay, Qt);
      if (inhibit_quit)
	specbind (Qinhibit_quit, Qt);
      /* Use Qt to ensure debugger does not run,
	 so there is no possibility of wanting to redisplay.  */
      val = internal_condition_case_n (Ffuncall, nargs, args, Qt,
				       safe_eval_handler);
      val = SAFE_FREE_UNBIND_TO (count, val);
    }

  return val;
}

Lisp_Object
safe_call (ptrdiff_t nargs, Lisp_Object func, ...)
{
  Lisp_Object retval;
  va_list ap;

  va_start (ap, func);
  retval = safe__call (false, nargs, func, ap);
  va_end (ap);
  return retval;
}

/* Call function FN with one argument ARG.
   Return the result, or nil if something went wrong.  */

Lisp_Object
safe_call1 (Lisp_Object fn, Lisp_Object arg)
{
  return safe_call (2, fn, arg);
}

static Lisp_Object
safe__call1 (bool inhibit_quit, Lisp_Object fn, ...)
{
  Lisp_Object retval;
  va_list ap;

  va_start (ap, fn);
  retval = safe__call (inhibit_quit, 2, fn, ap);
  va_end (ap);
  return retval;
}

Lisp_Object
safe_eval (Lisp_Object sexpr)
{
  return safe__call1 (false, Qeval, sexpr);
}

static Lisp_Object
safe__eval (bool inhibit_quit, Lisp_Object sexpr)
{
  return safe__call1 (inhibit_quit, Qeval, sexpr);
}

/* Call function FN with two arguments ARG1 and ARG2.
   Return the result, or nil if something went wrong.  */

Lisp_Object
safe_call2 (Lisp_Object fn, Lisp_Object arg1, Lisp_Object arg2)
{
  return safe_call (3, fn, arg1, arg2);
}



/***********************************************************************
			      Debugging
 ***********************************************************************/

/* Define CHECK_IT to perform sanity checks on iterators.
   This is for debugging.  It is too slow to do unconditionally.  */

static void
CHECK_IT (struct it *it)
{
#if false
  if (it->method == GET_FROM_STRING)
    {
      eassert (STRINGP (it->string));
      eassert (IT_STRING_CHARPOS (*it) >= 0);
    }
  else
    {
      eassert (IT_STRING_CHARPOS (*it) < 0);
      if (it->method == GET_FROM_BUFFER)
	{
	  /* Check that character and byte positions agree.  */
	  eassert (IT_CHARPOS (*it) == BYTE_TO_CHAR (IT_BYTEPOS (*it)));
	}
    }

  if (it->dpvec)
    eassert (it->current.dpvec_index >= 0);
  else
    eassert (it->current.dpvec_index < 0);
#endif
}
      </code>
    </pre>
  </body>
  <script src="js/animate.js"></script>
  <script>
    initAnimation();
  </script>
</html>
