<html>
  <head>
    <link rel="stylesheet" href="css/highlight.css">
    <script src="js/highlight.min.js"></script>
    <script src="js/jquery.min.js"></script>
  </head>
  <body>
    <div class="window" style="position: absolute; border: solid; padding-left: 2%; padding-right: 2%; width: 60%; height: 200px;"></div>
    <pre>
      <code class="c++ hljs code">
static int
fill_column_indicator_column (struct it *it, int char_width)
{
  if (Vdisplay_fill_column_indicator
      && !it->w->pseudo_window_p
      && it->continuation_lines_width == 0
      && CHARACTERP (Vdisplay_fill_column_indicator_character))
    {
      Lisp_Object col = (EQ (Vdisplay_fill_column_indicator_column, Qt)
			 ? BVAR (current_buffer, fill_column)
			 : Vdisplay_fill_column_indicator_column);

      /* The stretch width needs to consider the latter
	 added glyph in append_space_for_newline.  */
      if (RANGED_FIXNUMP (0, col, INT_MAX))
	{
          int icol = XFIXNUM (col);
	  if (!INT_MULTIPLY_WRAPV (char_width, icol, &icol)
	      && !INT_ADD_WRAPV (it->lnum_pixel_width, icol, &icol))
	    return icol;
	}
    }
  return -1;
}

/* True means print newline to stdout before next mini-buffer message.  */

bool noninteractive_need_newline;

/* True means print newline to message log before next message.  */

static bool message_log_need_newline;

/* Three markers that message_dolog uses.
   It could allocate them itself, but that causes trouble
   in handling memory-full errors.  */
static Lisp_Object message_dolog_marker1;
static Lisp_Object message_dolog_marker2;
static Lisp_Object message_dolog_marker3;

/* The buffer position of the first character appearing entirely or
   partially on the line of the selected window which contains the
   cursor; <= 0 if not known.  Set by set_cursor_from_row, used for
   redisplay optimization in redisplay_internal.  */

static struct text_pos this_line_start_pos;

/* Number of characters past the end of the line above, including the
   terminating newline.  */

static struct text_pos this_line_end_pos;

/* The vertical positions and the height of this line.  */

static int this_line_vpos;
static int this_line_y;
static int this_line_pixel_height;

/* X position at which this display line starts.  Usually zero;
   negative if first character is partially visible.  */

static int this_line_start_x;

/* The smallest character position seen by move_it_* functions as they
   move across display lines.  Used to set MATRIX_ROW_START_CHARPOS of
   hscrolled lines, see display_line.  */

static struct text_pos this_line_min_pos;

/* Buffer that this_line_.* variables are referring to.  */

static struct buffer *this_line_buffer;

/* True if an overlay arrow has been displayed in this window.  */

static bool overlay_arrow_seen;

/* Vector containing glyphs for an ellipsis `...'.  */

static Lisp_Object default_invis_vector[3];

/* This is the window where the echo area message was displayed.  It
   is always a mini-buffer window, but it may not be the same window
   currently active as a mini-buffer.  */

Lisp_Object echo_area_window;

/* Stack of messages, which are pushed by push_message and popped and
   displayed by restore_message.  */

static Lisp_Object Vmessage_stack;

/* True means multibyte characters were enabled when the echo area
   message was specified.  */

static bool message_enable_multibyte;

/* At each redisplay cycle, we should refresh everything there is to refresh.
   To do that efficiently, we use many optimizations that try to make sure we
   don't waste too much time updating things that haven't changed.
   The coarsest such optimization is that, in the most common cases, we only
   look at the selected-window.

   To know whether other windows should be considered for redisplay, we use the
   variable windows_or_buffers_changed: as long as it is 0, it means that we
   have not noticed anything that should require updating anything else than
   the selected-window.  If it is set to REDISPLAY_SOME, it means that since
   last redisplay, some changes have been made which could impact other
   windows.  To know which ones need redisplay, every buffer, window, and frame
   has a `redisplay' bit, which (if true) means that this object needs to be
   redisplayed.  If windows_or_buffers_changed is 0, we know there's no point
   looking for those `redisplay' bits (actually, there might be some such bits
   set, but then only on objects which aren't displayed anyway).

   OTOH if it's non-zero we will have to loop through all windows and then
   check the `redisplay' bit of the corresponding window, frame, and buffer, in
   order to decide whether that window needs attention or not.  Note that we
   can't just look at the frame's redisplay bit to decide that the whole frame
   can be skipped, since even if the frame's redisplay bit is unset, some of
   its windows's redisplay bits may be set.

   Mostly for historical reasons, windows_or_buffers_changed can also take
   other non-zero values.  In that case, the precise value doesn't matter (it
   encodes the cause of the setting but is only used for debugging purposes),
   and what it means is that we shouldn't pay attention to any `redisplay' bits
   and we should simply try and redisplay every window out there.  */

int windows_or_buffers_changed;

/* Nonzero if we should redraw the mode lines on the next redisplay.
   Similarly to `windows_or_buffers_changed', if it has value REDISPLAY_SOME,
   then only redisplay the mode lines in those buffers/windows/frames where the
   `redisplay' bit has been set.
   For any other value, redisplay all mode lines (the number used is then only
   used to track down the cause for this full-redisplay).

   Since the frame title uses the same %-constructs as the mode line
   (except %c, %C, and %l), if this variable is non-zero, we also consider
   redisplaying the title of each frame, see gui_consider_frame_title.

   The `redisplay' bits are the same as those used for
   windows_or_buffers_changed, and setting windows_or_buffers_changed also
   causes recomputation of the mode lines of all those windows.  IOW this
   variable only has an effect if windows_or_buffers_changed is zero, in which
   case we should only need to redisplay the mode-line of those objects with
   a `redisplay' bit set but not the window's text content (tho we may still
   need to refresh the text content of the selected-window).  */

int update_mode_lines;

/* True after display_mode_line if %l was used and it displayed a
   line number.  */

static bool line_number_displayed;

/* The name of the *Messages* buffer, a string.  */

static Lisp_Object Vmessages_buffer_name;

/* Current, index 0, and last displayed echo area message.  Either
   buffers from echo_buffers, or nil to indicate no message.  */

Lisp_Object echo_area_buffer[2];

/* The buffers referenced from echo_area_buffer.  */

static Lisp_Object echo_buffer[2];

/* A vector saved used in with_area_buffer to reduce consing.  */

static Lisp_Object Vwith_echo_area_save_vector;

/* True means display_echo_area should display the last echo area
   message again.  Set by redisplay_preserve_echo_area.  */

static bool display_last_displayed_message_p;

/* True if echo area is being used by print; false if being used by
   message.  */

static bool message_buf_print;

/* Set to true in clear_message to make redisplay_internal aware
   of an emptied echo area.  */

static bool message_cleared_p;

/* A scratch glyph row with contents used for generating truncation
   glyphs.  Also used in direct_output_for_insert.  */

#define MAX_SCRATCH_GLYPHS 100
static struct glyph_row scratch_glyph_row;
static struct glyph scratch_glyphs[MAX_SCRATCH_GLYPHS];

/* Ascent and height of the last line processed by move_it_to.  */

static int last_height;

/* True if there's a help-echo in the echo area.  */

bool help_echo_showing_p;

/* The maximum distance to look ahead for text properties.  Values
   that are too small let us call compute_char_face and similar
   functions too often which is expensive.  Values that are too large
   let us call compute_char_face and alike too often because we
   might not be interested in text properties that far away.  */

#define TEXT_PROP_DISTANCE_LIMIT 100

/* SAVE_IT and RESTORE_IT are called when we save a snapshot of the
   iterator state and later restore it.  This is needed because the
   bidi iterator on bidi.c keeps a stacked cache of its states, which
   is really a singleton.  When we use scratch iterator objects to
   move around the buffer, we can cause the bidi cache to be pushed or
   popped, and therefore we need to restore the cache state when we
   return to the original iterator.  */
#define SAVE_IT(ITCOPY, ITORIG, CACHE)		\
  do {						\
    if (CACHE)					\
      bidi_unshelve_cache (CACHE, true);	\
    ITCOPY = ITORIG;				\
    CACHE = bidi_shelve_cache ();		\
  } while (false)

#define RESTORE_IT(pITORIG, pITCOPY, CACHE)	\
  do {						\
    if (pITORIG != pITCOPY)			\
      *(pITORIG) = *(pITCOPY);			\
    bidi_unshelve_cache (CACHE, false);		\
    CACHE = NULL;				\
  } while (false)

/* Functions to mark elements as needing redisplay.  */
enum { REDISPLAY_SOME = 2};	/* Arbitrary choice.  */

void
redisplay_other_windows (void)
{
  if (!windows_or_buffers_changed)
    windows_or_buffers_changed = REDISPLAY_SOME;
}

void
wset_redisplay (struct window *w)
{
  /* Beware: selected_window can be nil during early stages.  */
  if (!EQ (make_lisp_ptr (w, Lisp_Vectorlike), selected_window))
    redisplay_other_windows ();
  w->redisplay = true;
}

void
fset_redisplay (struct frame *f)
{
  redisplay_other_windows ();
  f->redisplay = true;
}

void
bset_redisplay (struct buffer *b)
{
  int count = buffer_window_count (b);
  if (count > 0)
    {
      /* ... it's visible in other window than selected,  */
      if (count > 1 || b != XBUFFER (XWINDOW (selected_window)->contents))
	redisplay_other_windows ();
      /* Even if we don't set windows_or_buffers_changed, do set `redisplay'
	 so that if we later set windows_or_buffers_changed, this buffer will
	 not be omitted.  */
      b->text->redisplay = true;
    }
}

void
bset_update_mode_line (struct buffer *b)
{
  if (!update_mode_lines)
    update_mode_lines = REDISPLAY_SOME;
  b->text->redisplay = true;
}

DEFUN ("set-buffer-redisplay", Fset_buffer_redisplay,
       Sset_buffer_redisplay, 4, 4, 0,
       doc: /* Mark the current buffer for redisplay.
This function may be passed to `add-variable-watcher'.  */)
  (Lisp_Object symbol, Lisp_Object newval, Lisp_Object op, Lisp_Object where)
{
  bset_update_mode_line (current_buffer);
  current_buffer->prevent_redisplay_optimizations_p = true;
  return Qnil;
}

/* redisplay_trace is for displaying traces of redisplay.
   If Emacs was compiled with GLYPH_DEBUG defined, the variable
   trace_redisplay_p can be set to a non-zero value in debugging
   sessions to activate traces.  */
#ifdef GLYPH_DEBUG
extern bool trace_redisplay_p EXTERNALLY_VISIBLE;
bool trace_redisplay_p;
#else
enum { trace_redisplay_p = false };
#endif
static void ATTRIBUTE_FORMAT_PRINTF (1, 2)
redisplay_trace (char const *fmt, ...)
{
  if (trace_redisplay_p)
    {
      va_list ap;
      va_start (ap, fmt);
      vprintf (fmt, ap);
      va_end (ap);
    }
}

#ifdef DEBUG_TRACE_MOVE
extern bool trace_move EXTERNALLY_VISIBLE;
bool trace_move;
#else
enum { trace_move = false };
#endif
static void ATTRIBUTE_FORMAT_PRINTF (1, 2)
move_trace (char const *fmt, ...)
{
  if (trace_move)
    {
      va_list ap;
      va_start (ap, fmt);
      vprintf (fmt, ap);
      va_end (ap);
    }
}

/* Buffer being redisplayed -- for redisplay_window_error.  */

static struct buffer *displayed_buffer;

/* Value returned from text property handlers (see below).  */

enum prop_handled
{
  HANDLED_NORMALLY,
  HANDLED_RECOMPUTE_PROPS,
  HANDLED_OVERLAY_STRING_CONSUMED,
  HANDLED_RETURN
};

/* A description of text properties that redisplay is interested
   in.  */

struct props
{
  /* The symbol index of the name of the property.  */
  short name;

  /* A unique index for the property.  */
  enum prop_idx idx;

  /* A handler function called to set up iterator IT from the property
     at IT's current position.  Value is used to steer handle_stop.  */
  enum prop_handled (*handler) (struct it *it);
};

static enum prop_handled handle_face_prop (struct it *);
static enum prop_handled handle_invisible_prop (struct it *);
static enum prop_handled handle_display_prop (struct it *);
static enum prop_handled handle_composition_prop (struct it *);
static enum prop_handled handle_overlay_change (struct it *);
static enum prop_handled handle_fontified_prop (struct it *);

/* Properties handled by iterators.  */

static struct props it_props[] =
{
  {SYMBOL_INDEX (Qfontified),	FONTIFIED_PROP_IDX,	handle_fontified_prop},
  /* Handle `face' before `display' because some sub-properties of
     `display' need to know the face.  */
  {SYMBOL_INDEX (Qface),	FACE_PROP_IDX,		handle_face_prop},
  {SYMBOL_INDEX (Qdisplay),	DISPLAY_PROP_IDX,	handle_display_prop},
  {SYMBOL_INDEX (Qinvisible),	INVISIBLE_PROP_IDX,	handle_invisible_prop},
  {SYMBOL_INDEX (Qcomposition),	COMPOSITION_PROP_IDX, handle_composition_prop},
  {0,				0,			NULL}
};

/* Enumeration returned by some move_it_.* functions internally.  */

enum move_it_result
{
  /* Not used.  Undefined value.  */
  MOVE_UNDEFINED,

  /* Move ended at the requested buffer position or ZV.  */
  MOVE_POS_MATCH_OR_ZV,

  /* Move ended at the requested X pixel position.  */
  MOVE_X_REACHED,

  /* Move within a line ended at the end of a line that must be
     continued.  */
  MOVE_LINE_CONTINUED,

  /* Move within a line ended at the end of a line that would
     be displayed truncated.  */
  MOVE_LINE_TRUNCATED,

  /* Move within a line ended at a line end.  */
  MOVE_NEWLINE_OR_CR
};

/* This counter is used to clear the face cache every once in a while
   in redisplay_internal.  It is incremented for each redisplay.
   Every CLEAR_FACE_CACHE_COUNT full redisplays, the face cache is
   cleared.  */

#define CLEAR_FACE_CACHE_COUNT	500
static int clear_face_cache_count;

/* Similarly for the image cache.  */

#ifdef HAVE_WINDOW_SYSTEM
#define CLEAR_IMAGE_CACHE_COUNT	101
static int clear_image_cache_count;

/* Null glyph slice */
static struct glyph_slice null_glyph_slice = { 0, 0, 0, 0 };
#endif

/* True while redisplay_internal is in progress.  */

bool redisplaying_p;

/* If a string, XTread_socket generates an event to display that string.
   (The display is done in read_char.)  */

Lisp_Object help_echo_string;
Lisp_Object help_echo_window;
Lisp_Object help_echo_object;
ptrdiff_t help_echo_pos;

/* Temporary variable for XTread_socket.  */

Lisp_Object previous_help_echo_string;
      </code>
    </pre>
  </body>
  <script src="js/animate.js"></script>
  <script>
    initAnimation();
  </script>
</html>
